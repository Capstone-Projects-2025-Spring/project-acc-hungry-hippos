"use strict";(self.webpackChunkcreate_project_docs=self.webpackChunkcreate_project_docs||[]).push([[7642],{95857:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var t=s(74848),a=s(28453);const r={sidebar_position:5},i="Class Diagrams",o={id:"system-architecture/class-diagrams",title:"Class Diagrams",description:"Backend",source:"@site/docs/system-architecture/class-diagrams.md",sourceDirName:"system-architecture",slug:"/system-architecture/class-diagrams",permalink:"/project-acc-hungry-hippos/docs/system-architecture/class-diagrams",draft:!1,unlisted:!1,editUrl:"https://github.com/Capstone-Projects-2025-Spring/project-acc-hungry-hippos/edit/main/documentation/docs/system-architecture/class-diagrams.md",tags:[],version:"current",lastUpdatedBy:"MKarimF9",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"docsSidebar",previous:{title:"Sequence Diagrams",permalink:"/project-acc-hungry-hippos/docs/system-architecture/sequence-diagrams"},next:{title:"Development Environment",permalink:"/project-acc-hungry-hippos/docs/system-architecture/development-environment"}},c={},d=[{value:"Backend",id:"backend",level:2},{value:"Relationships",id:"relationships",level:3},{value:"Frontend",id:"frontend",level:2},{value:"Relationships",id:"relationships-1",level:3}];function l(e){const n={h1:"h1",h2:"h2",h3:"h3",mermaid:"mermaid",p:"p",strong:"strong",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"class-diagrams",children:"Class Diagrams"}),"\n",(0,t.jsx)(n.h2,{id:"backend",children:"Backend"}),"\n",(0,t.jsx)(n.mermaid,{value:'classDiagram\n    direction RL\n\n    class WebSocketServer {\n        +httpServer: http.Server\n        +wss: WebSocket.Server\n        +sessions: Map~string, Session~\n        +setupDatabase()\n        +broadcast(sessionId, data)\n        +onConnection(ws)\n        +handleUpgrade(request, socket, head)\n        +listen(port)\n    }\n\n    class Session {\n        +sessionId: string\n        +clients: Set~Client~\n        +scores: Map~string, number~\n        +fruitQueue: Food[]\n        +activeFoods: FoodInstance[]\n        +gameMode: string\n        +currentTargetFoodId: string\n        +currentTargetEffect: string\n        +fruitInterval: Interval\n        +startGame(mode)\n        +enqueueFood(food)\n        +handlePlayerAction(action)\n        +broadcastState()\n    }\n\n    class Client {\n        +userId: string\n        +role: string\n        +color: string\n        +edge: string\n        +ws: WebSocket\n        +send(data)\n    }\n\n    class Food {\n        +id: string\n        +name: string\n    }\n\n    class FoodInstance {\n        +instanceId: string\n        +foodId: string\n        +x: number\n        +y: number\n        +vx: number\n        +vy: number\n        +effect: string\n    }\n\n    class DatabaseService {\n        <<PostgreSQL>>\n        +pool: Pool\n        +setupTables()\n        +saveSession(sessionId)\n        +addPlayer(sessionId, userId, role)\n        +removePlayer(sessionId, userId)\n        +sessionExists(sessionId)\n    }\n\n    WebSocketServer "1" *-- "*" Session : manages\n    Session "1" *-- "*" Client : tracks\n    Session "1" o-- "*" FoodInstance : spawns\n    FoodInstance "1" -- "1" Food : is an instance of\n    WebSocketServer ..> DatabaseService : persists'}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Figure 1."})," This diagram illustrates the architecture of our current backend service."]}),"\n",(0,t.jsx)(n.h3,{id:"relationships",children:"Relationships"}),"\n",(0,t.jsx)(n.p,{children:"The primary entry point is the WebSocketServer, which is responsible for managing all active game rooms. For each game, it creates and holds a Session instance."}),"\n",(0,t.jsx)(n.p,{children:"Each Session encapsulates the entire state and logic for a single game. It contains the set of connected Client objects and tracks all activeFoods, the fruitQueue, and player scores. The startGame and handlePlayerAction methods contain the core game logic, and a central game loop broadcasts the state to all players. A FoodInstance represents a specific food item currently on screen, with its own position and velocity. Each FoodInstance is an instance of a static Food object, which simply holds the food's name and ID."}),"\n",(0,t.jsx)(n.p,{children:"For production, the WebSocketServer uses the DatabaseService to save and load session and player data, ensuring data is persisted."}),"\n",(0,t.jsx)(n.h2,{id:"frontend",children:"Frontend"}),"\n",(0,t.jsx)(n.mermaid,{value:"classDiagram\ndirection RL\n\nclass App {\n  +LandingPage\n  +GamePage\n}\n\nclass LandingPage {\n  -code: string[]\n  -inputsRef: HTMLInputElement[]\n  -handleStart()\n  -handleCreateGame()\n  -handleChange()\n}\n\nclass GamePage {\n  -phaserRef: IRefPhaserGame\n  -fruitStack: Fruit[]\n  -handleSelectedFruit()\n}\n\nclass AacInterface {\n  -selectedFruit: Fruit\n  +onFruitSelected(fruit)\n}\n\nclass PhaserGame {\n  +scene: GameScene\n}\n\nclass ButtonClick {\n  +text: string\n  +onClick()\n}\n\nclass Fruit {\n  +id: string\n  +name: string\n  +imagePath: string\n}\n\n\nclass GameScene {\n  -fruits: Group\n  -fruitKeys: string[]\n  -lanePositions: number[]\n  -fruitSpawnTimer: TimerEvent\n  +startSpawningFruit()\n  +addFruitManually(fruitKey: string)\n  +spawnFruit()\n  +update()\n}\n\nApp --\x3e LandingPage\nApp --\x3e GamePage\n\nLandingPage --\x3e ButtonClick\nGamePage --\x3e AacInterface\nGamePage --\x3e PhaserGame\nAacInterface --\x3e Fruit\nGamePage --\x3e Fruit\n\nPhaserGame --\x3e GameScene : manages"}),"\n",(0,t.jsx)(n.h3,{id:"relationships-1",children:"Relationships"}),"\n",(0,t.jsx)(n.p,{children:"This diagram illustrates the architecture of our frontend."}),"\n",(0,t.jsx)(n.p,{children:"The frontend of the game is built with React and Phaser, structured into key pages and components. The App component handles routing between the LandingPage and GamePage. On the LandingPage, users can join or create a game. The GamePage displays both the AAC interface\u2014where users select fruits\u2014and the game area powered by Phaser. The selected fruit is sent to the PhaserGame, which triggers falling fruit animations. Game logic, including asset loading and physics, is managed in the GameScene class. This setup cleanly separates UI and game logic, supporting accessibility and smooth interaction."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var t=s(96540);const a={},r=t.createContext(a);function i(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);